/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/plugin/versions": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the latest cs2kz-metamod releases. */
    get: operations["get_plugin_versions"]
    put?: never
    /** Notifies the API that a new version of cs2kz-metamod has been released. */
    post: operations["publish_plugin_version"]
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/plugin/versions/{version}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns metadata about the release of a specific cs2kz-metamod version. */
    get: operations["get_plugin_version"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/users": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns all users with permissions. */
    get: operations["get_users"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/users/{user_id}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the user with the specified ID. */
    get: operations["get_user"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/users/{user_id}/email": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    /** Updates a user's email address. */
    put: operations["update_user_email"]
    post?: never
    /** Deletes a user's email address. */
    delete: operations["delete_user_email"]
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/users/{user_id}/permissions": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    /**
     * Update a user's permissions.
     * @description This will **replace their current permissions**!
     */
    put: operations["update_user_permissions"]
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/auth/cs2": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Establishes a WebSocket connection with the requesting CS2 server. */
    get: operations["cs2_server_auth"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/auth/web": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns information about your current session. */
    get: operations["get_current_session"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/auth/web/login": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Login with Steam.
     * @description This endpoint will redirect you to Steam's login page.
     *
     *     Afterwards you will be redirected back here, and optionally to another URL if you specify the
     *     `redirect_to` query parameter.
     */
    get: operations["user_login"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/auth/web/logout": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Expires your current session immediately. */
    get: operations["user_logout"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/servers": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the most recently approved CS2 servers. */
    get: operations["get_servers"]
    put?: never
    /**
     * Approves a new CS2 server.
     * @description This will generate an access key which allows the server to submit records, jumpstats, etc.
     */
    post: operations["approve_server"]
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/servers/{server}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Returns the CS2 server with the specified ID / name.
     * @description If you specify a name, it does not have to be an exact match, although exact matches will be
     *     preferred.
     */
    get: operations["get_server"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/servers/{server_id}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    /** Updates a server's metadata. */
    patch: operations["update_server"]
    trace?: never
  }
  "/servers/{server_id}/access-key": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    /**
     * Generates a new access key for a server and invalidates the old one.
     * @description A successful request to this endpoint will also terminate the server's open WebSocket
     *     connection, if any.
     */
    put: operations["refresh_server_access_key"]
    post?: never
    /**
     * Deletes a server's access key.
     * @description A successful request to this endpoint will also terminate the server's open WebSocket
     *     connection, if any.
     */
    delete: operations["delete_server_access_key"]
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/players": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns CS2 players. */
    get: operations["get_players"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/players/{player}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the player with the specified ID / name. */
    get: operations["get_player"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/players/{player_id}/profile": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns a player's profile information. */
    get: operations["get_player_profile"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/players/{player_id}/steam-profile": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns a player's Steam profile. */
    get: operations["get_player_steam_profile"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/players/{player_id}/preferences": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns a player's cs2kz-metamod preferences. */
    get: operations["get_player_preferences"]
    /** Replaces a player's cs2kz-metamod preferences. */
    put: operations["update_player_preferences"]
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/maps": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the latest KZ maps. */
    get: operations["get_maps"]
    /** Approves a new map. */
    put: operations["approve_map"]
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/maps/{map}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the map with the specified ID / name. */
    get: operations["get_map"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/maps/{map_id}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    /**
     * Updates a map in-place.
     * @description This endpoint is used for simple metadata changes. Gameplay changes should be communicated
     *     through a separate version, i.e. `PUT /maps`.
     */
    patch: operations["update_map"]
    trace?: never
  }
  "/jumpstats": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the latest jumpstats. */
    get: operations["get_jumpstats"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/jumpstats/{jumpstat_id}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the jumpstat with the specified ID. */
    get: operations["get_jumpstat"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/jumpstats/{jumpstat_id}/replay": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the replay file for a specific jumpstat. */
    get: operations["get_jumpstat_replay"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/records": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the latest records. */
    get: operations["get_records"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/records/{record_id}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the record with the specified ID. */
    get: operations["get_record"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/records/{record_id}/replay": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the replay file for a specific record. */
    get: operations["get_record_replay"]
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/bans": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the latest player bans. */
    get: operations["get_bans"]
    put?: never
    /** Bans a player. */
    post: operations["create_ban"]
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  "/bans/{ban_id}": {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /** Returns the ban with the specified ID. */
    get: operations["get_ban"]
    put?: never
    post?: never
    /** Reverts a ban and creates an unban. */
    delete: operations["delete_ban"]
    options?: never
    head?: never
    /** Updates an active ban. */
    patch: operations["update_ban"]
    trace?: never
  }
}
export type webhooks = Record<string, never>
export interface components {
  schemas: {
    /**
     * Format: ulid
     * @description an opaque access key
     */
    AccessKey: string
    ApprovedMap: {
      /** Format: u-int16 */
      map_id: number
    }
    Ban: {
      /** Format: u-int32 */
      id: number
      player: components["schemas"]["PlayerInfo"]
      banned_by: components["schemas"]["BannedBy"]
      reason: components["schemas"]["BanReason"]
      unban?: null | components["schemas"]["Unban"]
      created_at: components["schemas"]["Timestamp"]
    }
    /** @enum {string} */
    BanReason: "macro" | "auto-bhop" | "auto-strafe"
    BanUpdate: {
      reason?: null | components["schemas"]["BanReason"]
      expires_at?: null | components["schemas"]["Timestamp"]
    }
    BannedBy:
      | {
          /**
           * Format: u-int16
           * @description The ban was issued by the Anti-Cheat on a CS2 server.
           */
          id: number
          /** @enum {string} */
          type: "server"
        }
      | {
          /** @description The ban was issued by an admin. */
          id: components["schemas"]["SteamId64"]
          /** @enum {string} */
          type: "admin"
        }
    /** @description an MD5 checksum */
    Checksum: string
    Course: {
      /** @description The course's name. */
      name: string
      /** @description A brief description of the course. */
      description?: string | null
      /** @description A list of players who have contributed to the creation of this course. */
      mappers: components["schemas"]["PlayerInfo"][]
      /** @description The filters for this course. */
      filters: components["schemas"]["CourseFilters"]
    }
    CourseFilter: {
      /** @description The difficulty level of this filter when teleports are allowed. */
      nub_tier: components["schemas"]["CourseFilterTier"]
      /** @description The difficulty level of this filter when no teleports are allowed. */
      pro_tier: components["schemas"]["CourseFilterTier"]
      /** @description The initial state the course should be in. */
      state: components["schemas"]["CourseFilterState"]
      /** @description Any additional notes on this filter (e.g. tiering justifications). */
      notes?: string | null
    }
    /** @enum {string} */
    CourseFilterState: "unranked" | "pending" | "ranked"
    /** @enum {string} */
    CourseFilterTier:
      | "very-easy"
      | "easy"
      | "medium"
      | "advanced"
      | "hard"
      | "very-hard"
      | "extreme"
      | "death"
      | "unfeasible"
      | "impossible"
    CourseFilters: {
      /** @description The filter for the VNL mode. */
      vanilla: components["schemas"]["CourseFilter"]
      /** @description The filter for the CKZ mode. */
      classic: components["schemas"]["CourseFilter"]
    }
    CourseInfo: {
      /**
       * Format: u-int16
       * @description The course's ID.
       */
      id: number
      /** @description The course's name. */
      name: string
      nub_tier: components["schemas"]["CourseFilterTier"]
      pro_tier: components["schemas"]["CourseFilterTier"]
    }
    CourseUpdate: {
      /** @description The index of the course to update.
       *
       *     Courses are 1-indexed and always returned in-order by the API. */
      idx: number
      /** @description A new name. */
      name?: string | null
      /** @description A new description. */
      description?: string | null
      /** @description SteamIDs to add to the course's mapper list. */
      added_mappers?: components["schemas"]["SteamId"][]
      /** @description SteamIDs to remove from the course's mapper list. */
      deleted_mappers?: components["schemas"]["SteamId"][]
      /** @description Updates to the course's filters. */
      filter_updates?: components["schemas"]["FilterUpdates"]
    }
    CreatedAccessKey: {
      /** @description The server's new access key. */
      access_key: components["schemas"]["AccessKey"]
    }
    CreatedBan: {
      /** Format: u-int32 */
      ban_id: number
    }
    CreatedServer: {
      /** Format: u-int16 */
      server_id: number
      /** @description The server's access key. */
      access_key: components["schemas"]["AccessKey"]
    }
    FilterUpdate: {
      nub_tier?: null | components["schemas"]["CourseFilterTier"]
      pro_tier?: null | components["schemas"]["CourseFilterTier"]
      state?: null | components["schemas"]["CourseFilterState"]
      /** @description New notes.
       *
       *     If you specify this, the old notes will be **replaced**! */
      notes?: string | null
    }
    FilterUpdates: {
      vanilla?: null | components["schemas"]["FilterUpdate"]
      classic?: null | components["schemas"]["FilterUpdate"]
    }
    /** @description a git revision */
    GitRevision: string
    /** @enum {string} */
    JumpType: "long-jump" | "bhop" | "multi-bhop" | "weird-jump" | "ladder-jump" | "ladderhop" | "jumpbug" | "fall"
    Jumpstat: {
      /** Format: u-int32 */
      id: number
      player: components["schemas"]["PlayerInfo"]
      server: components["schemas"]["ServerInfo"]
      mode: components["schemas"]["Mode"]
      styles: components["schemas"]["Styles"]
      jump_type: components["schemas"]["JumpType"]
      /**
       * Format: double
       * @description Airtime in seconds.
       */
      time: number
      /** Format: u-int8 */
      strafes: number
      /** Format: float */
      distance: number
      /** Format: float */
      sync: number
      /** Format: float */
      pre: number
      /** Format: float */
      max: number
      /** Format: float */
      overlap: number
      /** Format: float */
      bad_angles: number
      /** Format: float */
      dead_air: number
      /** Format: float */
      height: number
      /** Format: float */
      airpath: number
      /** Format: float */
      deviation: number
      /** Format: float */
      average_width: number
      submitted_at: components["schemas"]["Timestamp"]
    }
    /** Format: u-int64 */
    Limit: number
    Map: {
      /**
       * Format: u-int16
       * @description The map's ID in the API.
       */
      id: number
      /**
       * Format: u-int32
       * @description The map's ID on the Steam Workshop.
       */
      workshop_id: number
      /** @description The map's name. */
      name: string
      /** @description A brief description of the map. */
      description?: string | null
      /** @description The state the map is currently in. */
      state: components["schemas"]["MapState"]
      /** @description A checksum of the map's `.vpk` file. */
      vpk_checksum: string
      /** @description A list of players who have contributed to the creation of this map. */
      mappers: components["schemas"]["PlayerInfo"][]
      /** @description A list of courses present on the map. */
      courses: components["schemas"]["Course"][]
      /** @description When this map was approved. */
      approved_at: components["schemas"]["Timestamp"]
    }
    MapIdentifier: string | number
    MapInfo: {
      /**
       * Format: u-int16
       * @description The map's ID.
       */
      id: number
      /** @description The map's name. */
      name: string
    }
    /** @enum {string} */
    MapState: "invalid" | "in-testing" | "approved"
    MapUpdate: {
      /**
       * Format: u-int32
       * @description A new workshop ID.
       *
       *     This field is used for updating 3 things:
       *        - the map's workshop ID
       *        - the map's name
       *        - the map's vpk checksum
       */
      workshop_id?: number | null
      /** @description A new description. */
      description?: string | null
      state?: null | components["schemas"]["MapState"]
      /** @description SteamIDs to add to the map's mapper list. */
      added_mappers?: components["schemas"]["SteamId"][]
      /** @description SteamIDs to remove from the map's mapper list. */
      deleted_mappers?: components["schemas"]["SteamId"][]
      /** @description Updates to individual courses. */
      course_updates?: components["schemas"]["CourseUpdate"][]
    }
    /** @enum {string} */
    Mode: "vanilla" | "classic"
    NewBan: {
      /** @description The player that should be banned. */
      player_id: components["schemas"]["SteamId"]
      /**
       * Format: ipv4
       * @description The player's IP address.
       *
       *     If left unspecified, the player's last known IP address will be used instead.
       */
      player_ip?: string | null
      /** @description The reason for the ban. */
      reason: components["schemas"]["BanReason"]
    }
    NewCourse: {
      /** @description The course's name.
       *
       *     This has to be unique across all courses belonging to this map. */
      name: string
      /** @description A brief description of the course. */
      description?: string | null
      /** @description A list of SteamIDs of players who have contributed to the creation of this course.
       *
       *     You must specify at least 1 player. */
      mappers: components["schemas"]["SteamId"][]
      /** @description The filters for this course. */
      filters: components["schemas"]["CourseFilters"]
    }
    NewMap: {
      /**
       * Format: u-int32
       * @description The ID of the map's Steam workshop item.
       */
      workshop_id: number
      /** @description A brief description of the map. */
      description?: string | null
      /** @description The initial state the map should be in. */
      state: components["schemas"]["MapState"]
      /** @description A list of SteamIDs of players who have contributed to the creation of this map.
       *
       *     You must specify at least 1 player. */
      mappers: components["schemas"]["SteamId"][]
      /** @description A list of courses present on the map.
       *
       *     You must specify at least 1 course. */
      courses: components["schemas"]["NewCourse"][]
    }
    NewMode: {
      mode: components["schemas"]["Mode"]
      linux_checksum: components["schemas"]["Checksum"]
      windows_checksum: components["schemas"]["Checksum"]
    }
    NewPluginVersion: {
      /**
       * @description A SemVer version.
       * @example 1.23.456-dev
       */
      version: string
      /** @description The git revision associated with the release commit / tag. */
      git_revision: components["schemas"]["GitRevision"]
      /** @description Checksum of the plugin binary on Linux */
      linux_checksum: components["schemas"]["Checksum"]
      /** @description Checksum of the plugin binary on Windows */
      windows_checksum: components["schemas"]["Checksum"]
      /** @description Whether this release invalidates all previous releases */
      is_cutoff: boolean
      modes: components["schemas"]["NewMode"][]
      styles: components["schemas"]["NewStyle"][]
    }
    NewServer: {
      /** @description The server's name.
       *
       *     This has to be a unique value and will be displayed in UIs. */
      name: string
      /** @description The server's IP address / domain. */
      host: components["schemas"]["ServerHost"]
      /**
       * Format: u-int16
       * @description The server's connection port.
       */
      port: number
      /** @description The ID of the user who owns this server. */
      owner_id: components["schemas"]["SteamId64"]
    }
    NewStyle: {
      style: components["schemas"]["Style"]
      linux_checksum: components["schemas"]["Checksum"]
      windows_checksum: components["schemas"]["Checksum"]
    }
    NewUnban: {
      /** @description The reason for the unban. */
      reason: string
    }
    /** Format: int64 */
    Offset: number
    Paginated_Ban: {
      /**
       * Format: u-int64
       * @description The total number of values available for fetching.
       *
       *     Different endpoints have different hard-limits on how many values they will return at
       *     a time. They usually also have an `offset` query parameter you can use to fetch the next
       *     set of values. You can use `total` to infer when you can stop making requests.
       */
      total: number
      /** @description The values returned for this request. */
      values: {
        /** Format: u-int32 */
        id: number
        player: components["schemas"]["PlayerInfo"]
        banned_by: components["schemas"]["BannedBy"]
        reason: components["schemas"]["BanReason"]
        unban?: null | components["schemas"]["Unban"]
        created_at: components["schemas"]["Timestamp"]
      }[]
    }
    Paginated_Jumpstat: {
      /**
       * Format: u-int64
       * @description The total number of values available for fetching.
       *
       *     Different endpoints have different hard-limits on how many values they will return at
       *     a time. They usually also have an `offset` query parameter you can use to fetch the next
       *     set of values. You can use `total` to infer when you can stop making requests.
       */
      total: number
      /** @description The values returned for this request. */
      values: {
        /** Format: u-int32 */
        id: number
        player: components["schemas"]["PlayerInfo"]
        server: components["schemas"]["ServerInfo"]
        mode: components["schemas"]["Mode"]
        styles: components["schemas"]["Styles"]
        jump_type: components["schemas"]["JumpType"]
        /**
         * Format: double
         * @description Airtime in seconds.
         */
        time: number
        /** Format: u-int8 */
        strafes: number
        /** Format: float */
        distance: number
        /** Format: float */
        sync: number
        /** Format: float */
        pre: number
        /** Format: float */
        max: number
        /** Format: float */
        overlap: number
        /** Format: float */
        bad_angles: number
        /** Format: float */
        dead_air: number
        /** Format: float */
        height: number
        /** Format: float */
        airpath: number
        /** Format: float */
        deviation: number
        /** Format: float */
        average_width: number
        submitted_at: components["schemas"]["Timestamp"]
      }[]
    }
    Paginated_Map: {
      /**
       * Format: u-int64
       * @description The total number of values available for fetching.
       *
       *     Different endpoints have different hard-limits on how many values they will return at
       *     a time. They usually also have an `offset` query parameter you can use to fetch the next
       *     set of values. You can use `total` to infer when you can stop making requests.
       */
      total: number
      /** @description The values returned for this request. */
      values: {
        /**
         * Format: u-int16
         * @description The map's ID in the API.
         */
        id: number
        /**
         * Format: u-int32
         * @description The map's ID on the Steam Workshop.
         */
        workshop_id: number
        /** @description The map's name. */
        name: string
        /** @description A brief description of the map. */
        description?: string | null
        /** @description The state the map is currently in. */
        state: components["schemas"]["MapState"]
        /** @description A checksum of the map's `.vpk` file. */
        vpk_checksum: string
        /** @description A list of players who have contributed to the creation of this map. */
        mappers: components["schemas"]["PlayerInfo"][]
        /** @description A list of courses present on the map. */
        courses: components["schemas"]["Course"][]
        /** @description When this map was approved. */
        approved_at: components["schemas"]["Timestamp"]
      }[]
    }
    Paginated_Player: {
      /**
       * Format: u-int64
       * @description The total number of values available for fetching.
       *
       *     Different endpoints have different hard-limits on how many values they will return at
       *     a time. They usually also have an `offset` query parameter you can use to fetch the next
       *     set of values. You can use `total` to infer when you can stop making requests.
       */
      total: number
      /** @description The values returned for this request. */
      values: {
        /** @description The player's SteamID. */
        id: components["schemas"]["SteamId"]
        /** @description The player's name on Steam. */
        name: string
        /** @description When this player first joined an approved CS2 server. */
        first_joined_at: components["schemas"]["Timestamp"]
      }[]
    }
    Paginated_PluginVersion: {
      /**
       * Format: u-int64
       * @description The total number of values available for fetching.
       *
       *     Different endpoints have different hard-limits on how many values they will return at
       *     a time. They usually also have an `offset` query parameter you can use to fetch the next
       *     set of values. You can use `total` to infer when you can stop making requests.
       */
      total: number
      /** @description The values returned for this request. */
      values: {
        /** Format: u-int16 */
        id: number
        /**
         * @description A SemVer version.
         * @example 1.23.456-dev
         */
        version: string
        /** @description The git revision associated with the release commit / tag of this version. */
        git_revision: components["schemas"]["GitRevision"]
        /** @description When this version was published. */
        published_at: components["schemas"]["Timestamp"]
      }[]
    }
    Paginated_Record: {
      /**
       * Format: u-int64
       * @description The total number of values available for fetching.
       *
       *     Different endpoints have different hard-limits on how many values they will return at
       *     a time. They usually also have an `offset` query parameter you can use to fetch the next
       *     set of values. You can use `total` to infer when you can stop making requests.
       */
      total: number
      /** @description The values returned for this request. */
      values: {
        /** Format: u-int32 */
        id: number
        player: components["schemas"]["PlayerInfo"]
        server: components["schemas"]["ServerInfo"]
        map: components["schemas"]["MapInfo"]
        course: components["schemas"]["CourseInfo"]
        mode: components["schemas"]["Mode"]
        styles: components["schemas"]["Styles"]
        /** Format: u-int32 */
        teleports: number
        /**
         * Format: double
         * @description Time in seconds.
         */
        time: number
        /** Format: u-int32 */
        nub_rank?: number | null
        /** Format: double */
        nub_points?: number | null
        /** Format: u-int32 */
        pro_rank?: number | null
        /** Format: double */
        pro_points?: number | null
        submitted_at: components["schemas"]["Timestamp"]
      }[]
    }
    Paginated_Server: {
      /**
       * Format: u-int64
       * @description The total number of values available for fetching.
       *
       *     Different endpoints have different hard-limits on how many values they will return at
       *     a time. They usually also have an `offset` query parameter you can use to fetch the next
       *     set of values. You can use `total` to infer when you can stop making requests.
       */
      total: number
      /** @description The values returned for this request. */
      values: {
        /** Format: u-int16 */
        id: number
        name: string
        /** @description The server's IP address / domain. */
        host: components["schemas"]["ServerHost"]
        /** Format: u-int16 */
        port: number
        /** @description The user who owns this server. */
        owner: components["schemas"]["UserInfo"]
        /** @description When this server was approved by the API. */
        approved_at: components["schemas"]["Timestamp"]
      }[]
    }
    Paginated_User: {
      /**
       * Format: u-int64
       * @description The total number of values available for fetching.
       *
       *     Different endpoints have different hard-limits on how many values they will return at
       *     a time. They usually also have an `offset` query parameter you can use to fetch the next
       *     set of values. You can use `total` to infer when you can stop making requests.
       */
      total: number
      /** @description The values returned for this request. */
      values: {
        /** @description The user's SteamID. */
        id: components["schemas"]["SteamId64"]
        /**
         * @description The user's last-known name on Steam.
         * @example AlphaKeks
         */
        name: string
        /** @description The user's API permissions. */
        permissions: components["schemas"]["Permissions"]
        /** @description When this user was registered to the API. */
        registered_at: components["schemas"]["Timestamp"]
      }[]
    }
    Permissions: ("user-permissions" | "servers" | "map-pool" | "player-bans")[]
    Player: {
      /** @description The player's SteamID. */
      id: components["schemas"]["SteamId"]
      /** @description The player's name on Steam. */
      name: string
      /** @description When this player first joined an approved CS2 server. */
      first_joined_at: components["schemas"]["Timestamp"]
    }
    PlayerIdentifier: string
    PlayerInfo: {
      /** @description The player's SteamID. */
      id: components["schemas"]["SteamId"]
      /** @description The player's name on Steam. */
      name: string
    }
    PluginVersion: {
      /** Format: u-int16 */
      id: number
      /**
       * @description A SemVer version.
       * @example 1.23.456-dev
       */
      version: string
      /** @description The git revision associated with the release commit / tag of this version. */
      git_revision: components["schemas"]["GitRevision"]
      /** @description When this version was published. */
      published_at: components["schemas"]["Timestamp"]
    }
    PluginVersionIdentifier: string
    PublishedPluginVersion: {
      /** Format: u-int16 */
      plugin_version_id: number
    }
    Record: {
      /** Format: u-int32 */
      id: number
      player: components["schemas"]["PlayerInfo"]
      server: components["schemas"]["ServerInfo"]
      map: components["schemas"]["MapInfo"]
      course: components["schemas"]["CourseInfo"]
      mode: components["schemas"]["Mode"]
      styles: components["schemas"]["Styles"]
      /** Format: u-int32 */
      teleports: number
      /**
       * Format: double
       * @description Time in seconds.
       */
      time: number
      /** Format: u-int32 */
      nub_rank?: number | null
      /** Format: double */
      nub_points?: number | null
      /** Format: u-int32 */
      pro_rank?: number | null
      /** Format: double */
      pro_points?: number | null
      submitted_at: components["schemas"]["Timestamp"]
    }
    /** @enum {string} */
    Records_SortBy: "submission-date" | "time"
    /** @enum {string} */
    Records_SortOrder: "ascending" | "descending"
    /** Format: binary */
    ReplayFile: Record<string, never>
    Server: {
      /** Format: u-int16 */
      id: number
      name: string
      /** @description The server's IP address / domain. */
      host: components["schemas"]["ServerHost"]
      /** Format: u-int16 */
      port: number
      /** @description The user who owns this server. */
      owner: components["schemas"]["UserInfo"]
      /** @description When this server was approved by the API. */
      approved_at: components["schemas"]["Timestamp"]
    }
    /**
     * Format: hostname
     * @description an IPv4/IPv6 address or domain
     */
    ServerHost: string
    ServerIdentifier: string | number
    ServerInfo: {
      /**
       * Format: u-int16
       * @description The server's ID.
       */
      id: number
      /** @description The server's name. */
      name: string
    }
    ServerUpdate: {
      /** @description A new name. */
      name?: string | null
      host?: null | components["schemas"]["ServerHost"]
      /**
       * Format: u-int16
       * @description A new port.
       */
      port?: number | null
      owner_id?: null | components["schemas"]["SteamId64"]
    }
    SessionInfo: {
      /** @description When your session was created. */
      created_at: components["schemas"]["Timestamp"]
      /** @description When your session will expire. */
      expires_at: components["schemas"]["Timestamp"]
    }
    /** @description a SteamID */
    SteamId: string
    /**
     * Format: u-int64
     * @description a 64-bit SteamID
     */
    SteamId64: string
    SteamUser: {
      id: components["schemas"]["SteamId"]
      name: string
      /** Format: uri */
      profile_url: string
      /** Format: uri */
      avatar_url: string
    }
    /** @enum {string} */
    Style: "auto-bhop"
    Styles: "auto-bhop"[]
    /**
     * Format: date-time
     * @description a UTC timestamp
     */
    Timestamp: string
    Unban: {
      admin_id: components["schemas"]["SteamId64"]
      reason: string
      created_at: components["schemas"]["Timestamp"]
    }
    UpdateUserEmailPayload: {
      /**
       * Format: email
       * @description The new email address.
       */
      email: string
    }
    UpdateUserPermissionsPayload: {
      /** @description The new permissions. */
      permissions: components["schemas"]["Permissions"]
    }
    User: {
      /** @description The user's SteamID. */
      id: components["schemas"]["SteamId64"]
      /**
       * @description The user's last-known name on Steam.
       * @example AlphaKeks
       */
      name: string
      /** @description The user's API permissions. */
      permissions: components["schemas"]["Permissions"]
      /** @description When this user was registered to the API. */
      registered_at: components["schemas"]["Timestamp"]
    }
    UserInfo: {
      /** @description The user's SteamID. */
      id: components["schemas"]["SteamId64"]
      /** @description The user's last-known name on Steam. */
      name: string
    }
  }
  responses: never
  parameters: never
  requestBodies: never
  headers: never
  pathItems: never
}
export type $defs = Record<string, never>
export interface operations {
  get_plugin_versions: {
    parameters: {
      query?: {
        /**
         * @description Only include versions that meet this SemVer requirement.
         * @example ^1.0.0
         */
        version?: string
        limit?: components["schemas"]["Limit"]
        offset?: components["schemas"]["Offset"]
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Paginated_PluginVersion"]
        }
      }
      /** @description invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  publish_plugin_version: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewPluginVersion"]
      }
    }
    responses: {
      201: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["PublishedPluginVersion"]
        }
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description The submitted version already exists or is older than the current latest version. */
      409: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid request body */
      422: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_plugin_version: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description a SemVer version or git revision */
        version: components["schemas"]["PluginVersionIdentifier"]
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["PluginVersion"]
        }
      }
      /** @description invalid path parameter */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_users: {
    parameters: {
      query?: {
        /** @description Only include users with these permissions. */
        permissions?: components["schemas"]["Permissions"]
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Paginated_User"]
        }
      }
      /** @description invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_user: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the user's SteamID */
        user_id: components["schemas"]["SteamId64"]
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["User"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  update_user_email: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the user's SteamID */
        user_id: components["schemas"]["SteamId64"]
      }
      cookie?: never
    }
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserEmailPayload"]
      }
    }
    responses: {
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid request body */
      422: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  delete_user_email: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the user's SteamID */
        user_id: components["schemas"]["SteamId64"]
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  update_user_permissions: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the user's SteamID */
        user_id: components["schemas"]["SteamId64"]
      }
      cookie?: never
    }
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserPermissionsPayload"]
      }
    }
    responses: {
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid request body */
      422: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  cs2_server_auth: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      101: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_current_session: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["SessionInfo"]
        }
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  user_login: {
    parameters: {
      query?: {
        /** @description URL you wish to be redirected to after the login process is complete. */
        redirect_to?: string
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Redirect to Steam's login page. */
      303: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  user_logout: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_servers: {
    parameters: {
      query?: {
        /** @description Only include servers whose name matches this value. */
        name?: string
        /** @description Only include servers whose host matches this value. */
        host?: components["schemas"]["ServerHost"]
        /** @description Only include servers owned by this user. */
        owned_by?: components["schemas"]["SteamId64"]
        limit?: components["schemas"]["Limit"]
        offset?: components["schemas"]["Offset"]
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Paginated_Server"]
        }
      }
      /** @description invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  approve_server: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewServer"]
      }
    }
    responses: {
      201: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["CreatedServer"]
        }
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description The server's name or host+port combination is already in use. */
      409: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid request body */
      422: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_server: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description a server ID or name */
        server: components["schemas"]["ServerIdentifier"]
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Server"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  update_server: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the server's ID */
        server_id: number
      }
      cookie?: never
    }
    requestBody: {
      content: {
        "application/json": components["schemas"]["ServerUpdate"]
      }
    }
    responses: {
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description The specified name or host+port combination is already in use. */
      409: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid request body */
      422: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  refresh_server_access_key: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the server's ID */
        server_id: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      201: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["CreatedAccessKey"]
        }
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  delete_server_access_key: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the server's ID */
        server_id: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_players: {
    parameters: {
      query?: {
        /** @description Only include players whose name matches this value. */
        name?: string
        limit?: components["schemas"]["Limit"]
        offset?: components["schemas"]["Offset"]
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Paginated_Player"]
        }
      }
      /** @description invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_player: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description a SteamID or name */
        player: components["schemas"]["PlayerIdentifier"]
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Player"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_player_profile: {
    parameters: {
      query: {
        mode: components["schemas"]["Mode"]
      }
      header?: never
      path: {
        /** @description the player's SteamID */
        player_id: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Player"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_player_steam_profile: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the player's SteamID */
        player_id: components["schemas"]["SteamId"]
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["SteamUser"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description Steam returned an error */
      502: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_player_preferences: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the player's SteamID */
        player_id: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": Record<string, never>
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  update_player_preferences: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the player's SteamID */
        player_id: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_maps: {
    parameters: {
      query?: {
        /** @description Only include maps with this Steam Workshop ID.
         *
         *     As multiple versions of the same map are represented as different maps, a request may
         *     return multiple values (multiple versions of the same map with the same workshop ID). */
        workshop_id?: number
        /** @description Only include maps whose name matches this value. */
        name?: string
        /** @description Only include maps currently in this state. */
        state?: components["schemas"]["MapState"]
        limit?: components["schemas"]["Limit"]
        offset?: components["schemas"]["Offset"]
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Paginated_Map"]
        }
      }
      /** @description invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  approve_map: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewMap"]
      }
    }
    responses: {
      201: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["ApprovedMap"]
        }
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid request body */
      422: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_map: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description a map ID or name */
        map: components["schemas"]["MapIdentifier"]
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Map"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  update_map: {
    parameters: {
      query?: never
      header?: never
      path: {
        /** @description the map's ID */
        map_id: number
      }
      cookie?: never
    }
    requestBody: {
      content: {
        "application/json": components["schemas"]["MapUpdate"]
      }
    }
    responses: {
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      409: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid request body */
      422: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_jumpstats: {
    parameters: {
      query?: {
        limit?: components["schemas"]["Limit"]
        offset?: components["schemas"]["Offset"]
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Paginated_Jumpstat"]
        }
      }
      /** @description invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_jumpstat: {
    parameters: {
      query?: never
      header?: never
      path: {
        jumpstat_id: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Jumpstat"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_jumpstat_replay: {
    parameters: {
      query?: never
      header?: never
      path: {
        jumpstat_id: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["ReplayFile"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_records: {
    parameters: {
      query?: {
        /** @description Only include PBs. */
        top?: boolean
        /** @description Only include records set by this player. */
        player?: components["schemas"]["PlayerIdentifier"]
        /** @description Only include records set on this server. */
        server?: components["schemas"]["ServerIdentifier"]
        /** @description Only include records set on this map. */
        map?: components["schemas"]["MapIdentifier"]
        /** @description Only include records set on this course. */
        course?: string
        /** @description Only include records set on this mode. */
        mode?: components["schemas"]["Mode"]
        /** @description Restrict the results to records that (do not) have teleports. */
        has_teleports?: boolean
        /** @description The highest rank that any record should have.
         *
         *     This can be used, for example, to query world records only (`max_rank=1`). */
        max_rank?: number
        /** @description Which value to sort the results by.
         *
         *     Defaults to 'submission-date'. */
        sort_by?: components["schemas"]["Records_SortBy"]
        /** @description Which direction to sort the results in. */
        sort_order?: components["schemas"]["Records_SortOrder"]
        limit?: components["schemas"]["Limit"]
        offset?: components["schemas"]["Offset"]
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Paginated_Record"]
        }
      }
      /** @description invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_record: {
    parameters: {
      query?: never
      header?: never
      path: {
        record_id: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Record"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_record_replay: {
    parameters: {
      query?: never
      header?: never
      path: {
        record_id: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["ReplayFile"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_bans: {
    parameters: {
      query?: {
        /** @description Only include bans for this player. */
        player?: components["schemas"]["PlayerIdentifier"]
        /** @description Only include bans issued by this user. */
        banned_by?: components["schemas"]["SteamId64"]
        /** @description Only include bans with this reason. */
        reason?: components["schemas"]["BanReason"]
        limit?: components["schemas"]["Limit"]
        offset?: components["schemas"]["Offset"]
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Paginated_Ban"]
        }
      }
      /** @description invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  create_ban: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewBan"]
      }
    }
    responses: {
      201: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["CreatedBan"]
        }
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description the player is already banned */
      409: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid request body */
      422: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  get_ban: {
    parameters: {
      query?: never
      header?: never
      path: {
        ban_id: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          "application/json": components["schemas"]["Ban"]
        }
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  delete_ban: {
    parameters: {
      query?: never
      header?: never
      path: {
        ban_id: number
      }
      cookie?: never
    }
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewUnban"]
      }
    }
    responses: {
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid request body */
      422: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
  update_ban: {
    parameters: {
      query?: never
      header?: never
      path: {
        ban_id: number
      }
      cookie?: never
    }
    requestBody: {
      content: {
        "application/json": components["schemas"]["BanUpdate"]
      }
    }
    responses: {
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid path parameters */
      400: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      401: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      404: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description invalid request body */
      422: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
    }
  }
}
